<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Breakout</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
<script>   
    //game parameters
    const PADDLE_SPD = 0.5; //fraction of screen width/second
    const BALL_SPD = 0.5; //starting ball speed in fraction of screed height/second
    const MAX_BALL_SPD = 2 //max ball speed as multiple of starting speed
    const PADDLE_W = 0.1; //paddle width as fraction of screen width
    const WALL = 0.02; //wall/ball size as fraction of shortest screen dimension
    const PADDLE_SIZE = 1.5; //paddle size as multiple of wall thickness (to adjust so ball doesn't clip when moving too fast due to FPS)
    const BRICK_ROWS = 8; //starting number of brick rows
    const BRICK_COLS = 14; //number of brick columns
    const BRICK_GAP = 0.3 //gap between bricks as fraction of wall width
    const MARGIN = 6; //number of empty rows above bricks
    const MAX_LEVEL = 10; //maximum game level (+2 rows of bricks per level)
    const GAME_LIVES = 3; //starting number of lives
    const KEY_SCORE = "highscore"; //save key for local storage of high score
    const PUP_CHANCE = 1; //chance of powerup dropping from broken brick (0-1)
    const PUP_SPD = 0.15; //powerup speed as faction of screen height/second
    const PUP_BONUS = 50; //bonus points for collecting redundant powerup

    //colors
    const COLOR_BACKGROUND = "black";
    const COLOR_WALL = "gray";
    const COLOR_PADDLE = "white";
    const COLOR_BALL = "white";
    const COLOR_TEXT = "white";

    //text 
    const TEXT_FONT = "Lucida Console";
    const TEXT_LEVEL = "Level";
    const TEXT_LIVES = "Ball";
    const TEXT_SCORE = "Score";
    const TEXT_SCORE_HIGH = "BEST";
    const TEXT_GAME_OVER = "GAME OVER!";
    const TEXT_WIN = "YOU WIN!";

    //definitions 
    const Direction = {
        LEFT: 0,
        RIGHT: 1,
        STOP: 2
    }

    const PupType = {
        EXTENSION: {color: "dodgerblue", symbol: "="},
        LIFE: {color: "hotpink", symbol: "+"},
        STICKY: {color: "forestgreen", symbol: "~"},
        SUPER: {color: "purple", symbol: "s"},
    }

    //set up game canvas and context
    var canv = document.createElement("canvas");
    document.body.appendChild(canv);
    var ctx = canv.getContext("2d");

    //set up sound effects
    var fxBrick = new Audio("sounds/brick.m4a");
    var fxPaddle = new Audio("sounds/paddle.m4a");
    var fxPowerUp = new Audio("sounds/powerup.m4a");
    var fxWall = new Audio("sounds/wall.m4a");

    //game variables
    var paddle, ball, bricks = [], pups = [];
    var gameOver, win, pupExtension, pupSticky, pupSuper;
    var level, lives, score, scoreHigh;
    var numBricks, textSize, touchX;
    var currentSpd;

    //derived dimensions
    var height, width, wall;
    setDimensions();

    //event listeners
    canv.addEventListener("touchcancel", touchCancel);
    canv.addEventListener("touchend", touchEnd);
    canv.addEventListener("touchmove", touchMove);
    canv.addEventListener("touchstart", touchStart);
    document.addEventListener("keydown", keyDown);
    document.addEventListener("keyup", keyUp);
    window.addEventListener("resize", setDimensions);

    //set up game loop
    var timeDelta, timeLast;
    requestAnimationFrame(loop);

    function loop(timeNow) {
        if (!timeLast) {
            timeLast = timeNow;
        }

        //calculate time difference
        timeDelta = (timeNow - timeLast) / 1000; //seconds
        timeLast = timeNow;

        //update
        if (!gameOver) {
            updatePaddle(timeDelta);
            updateBall(timeDelta);
            updateBricks(timeDelta);
            updatePups(timeDelta);
        }
        
        //draw
        drawBackground();
        drawWalls();
        drawPups();
        drawPaddle();
        drawBricks();
        drawText();
        drawBall();

        //call next loop (recursion)
        requestAnimationFrame(loop);
    }

    function applyBallSpeed(angle) {
        //update x and y velocities of ball
        ball.xv = ball.spd * Math.cos(angle);
        ball.yv = -ball.spd * Math.sin(angle);
    }

    function keyDown(ev) {
        switch (ev.keyCode) {
            case 37: //left arrow moves paddle left
                movePaddle(Direction.LEFT);
                break;
            case 39: //right arrow moves paddle right
                movePaddle(Direction.RIGHT);
                break;
            case 32: //space bar serves ball
                serve();
                if (gameOver) {
                    newGame();
                }
                break;
        }
    }

    function keyUp(ev) {
        switch (ev.keyCode) {
            case 37: //releasing left arrow stops paddle
            case 39: //releasing right arrow stops paddle
                movePaddle(Direction.STOP);
                break;
        }
    }

    function createBricks() {
        
        //row dimensions 
        let minY = wall;
        let maxY = ball.y - ball.h * 3.5
        let totalSpaceY = maxY - minY;
        let totalRows = MARGIN + BRICK_ROWS + MAX_LEVEL * 2
        let rowH = totalSpaceY / totalRows;
        let gap = wall * BRICK_GAP;
        let h = rowH - gap;
        textSize = rowH * MARGIN * 0.5;

        //column dimensions
        let totalSpaceX = width - wall * 2
        let colW = (totalSpaceX - gap) / BRICK_COLS;
        let w = colW - gap;

        //populate bricks array
        bricks = [];
        let cols = BRICK_COLS;
        let rows = BRICK_ROWS + level * 2;
        let color, left, top, rank, score, spdMult, rankHigh;
        numBricks = cols * rows;
        rankHigh = rows * 0.5 - 1;
        for (let i = 0; i < rows; i++) {
            bricks[i] = [];
            rank = Math.floor(i * 0.5);
            score = (rankHigh - rank) * 2 + 1;
            spdMult = 1 + (rankHigh - rank) / rankHigh * (MAX_BALL_SPD - 1);
            color = getBrickColor(rank, rankHigh);
            top = wall + (MARGIN + i) * rowH;
            for (let j = 0; j < cols; j++) {
                left = wall + gap + j * colW;
                bricks[i][j] = new Brick(left, top, w, h, color, score, spdMult);
            }
        }
    }

    function drawBackground() {
        ctx.fillStyle = COLOR_BACKGROUND;
        ctx.fillRect(0, 0, canv.width, canv.height);
    }

    function drawPaddle() {
        ctx.fillStyle = pupSticky ? PupType.STICKY.color : COLOR_PADDLE;
        ctx.fillRect(paddle.x - paddle.w * 0.5, paddle.y - paddle.h * 0.5, paddle.w, paddle.h)
    }

    function drawPups() {
        ctx.lineWidth = wall * 0.35;
        for (let pup of pups) {
            ctx.fillStyle = pup.type.color;
            ctx.strokeStyle = pup.type.color;
            ctx.strokeRect(pup.x - pup.w * 0.5, pup.y - pup.h * 0.5, pup.w, pup.h);
            ctx.font = "bold " + pup.h + "px " + TEXT_FONT;
            ctx.textAlign = "center";
            ctx.fillText(pup.type.symbol, pup.x, pup.y + pup.h * 0.25);
        }
    }

    function drawText() {
        ctx.fillStyle = COLOR_TEXT;

        //dimensions
        let labelSize = textSize * 0.5;
        let margin = wall * 2;
        let maxWidth = width - margin * 2;
        let maxWidth1 = maxWidth * 0.27;
        let maxWidth2 = maxWidth * 0.2;
        let maxWidth3 = maxWidth * 0.2;
        let maxWidth4 = maxWidth * 0.27;
        let x1 = margin;
        let x2 = width * 0.4;
        let x3 = width * 0.6;
        let x4 = width - margin;
        let yLabel = wall + labelSize;
        let yValue = yLabel + textSize * 0.9;

        //labels
        ctx.font = labelSize + "px " + TEXT_FONT;
        ctx.textAlign = "left";
        ctx.fillText(TEXT_SCORE, x1, yLabel, maxWidth1);
        ctx.textAlign = "center"
        ctx.fillText(TEXT_LIVES, x2, yLabel, maxWidth2);
        ctx.fillText(TEXT_LEVEL, x3, yLabel, maxWidth3);
        ctx.textAlign = "right"
        ctx.fillText(TEXT_SCORE_HIGH, x4, yLabel, maxWidth4);

        //values
        ctx.font = textSize + "px " + TEXT_FONT;
        ctx.textAlign = "left";
        ctx.fillText(score, x1, yValue, maxWidth1);
        ctx.textAlign = "center"
        ctx.fillText(lives + "/" + GAME_LIVES, x2, yValue, maxWidth2);
        ctx.fillText(level, x3, yValue, maxWidth3);
        ctx.textAlign = "right"
        ctx.fillText(scoreHigh, x4, yValue, maxWidth4);

        //game over
        if (gameOver) {
            let text = win ? TEXT_WIN : TEXT_GAME_OVER;
            ctx.font = textSize + "px " + TEXT_FONT;
            ctx.textAlign = "center";
            ctx.fillText(TEXT_GAME_OVER, width * 0.5, paddle.y - textSize, maxWidth);
        }

    }

    function drawBall() {
        ctx.fillStyle = pupSuper ? PupType.SUPER.color : COLOR_BALL;

        //rectangle ball
        //ctx.fillRect(ball.x - ball.w * 0.5, ball.y - ball.h * 0.5, ball.w, ball.h)

        //round ball
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.w * 0.5, 0, Math.PI * 2);
        ctx.fill();
    }

    function drawBricks() {
        for (let row of bricks) {
            for (let brick of row) {
                if (brick == null) {
                    continue;
                }
                ctx.fillStyle = brick.color;
                ctx.fillRect(brick.left, brick.top, brick.w, brick.h)
            }
        }
    }

    function drawWalls() {
        let hwall = wall * 0.5;
        ctx.lineWidth = wall;
        ctx.strokeStyle = COLOR_WALL;
        ctx.beginPath();
        ctx.moveTo(hwall, height);
        ctx.lineTo(hwall, hwall);
        ctx.lineTo(width - hwall, hwall);
        ctx.lineTo(width - hwall, height);
        ctx.stroke();
    }

    //red = 0, orange = 0.33, yellow = 0.67, green = 1
    function getBrickColor(rank, highestRank) {
        let fraction = rank / highestRank;
        let r, g, b = 0;

        //red to orange to yellow (increase green)
        if (fraction <= 0.67) {
            r = 255;
            g = 255 * fraction / 0.67;
        }

        //yellow to green (reduce red)
        else {
            r = 255 * (1 - fraction) / 0.33;
            g = 255;
        }

        //return rgb color string
        return "rgb(" + r + ", " + g + ", " + b + ")";
    }

    function movePaddle(direction) {
        switch (direction) {
            case Direction.LEFT: 
                paddle.xv = -paddle.spd;
                break;
            case Direction.RIGHT:
                paddle.xv = paddle.spd;
                break;
            case Direction.STOP:
                paddle.xv = 0;
                break;
        }
    }

    function newBall() {
        pupExtension = false;
        pupSticky = false;
        pupSuper = false;
        paddle = new Paddle();
        ball = new Ball();
    }

    function newGame() {
        gameOver = false;
        lives = GAME_LIVES;
        score = 0;
        level = 0;
        win = false;

        //get high score from local storage
        let scoreStr = localStorage.getItem(KEY_SCORE);
        if (scoreStr == null) {
            scoreHigh = 0;
        } else {
            scoreHigh = parseInt(scoreStr);
        }

        //start new level
        newLevel();
    }

    function newLevel() {
        pups = [];
        touchX = null;
        newBall();
        createBricks();
    }

    function outOfBounds() {
        lives--;
        if (lives == 0) {
            gameOver = true;
        }
        newBall();
    }

    function fetchCurrentSpd() {
        currentSpd = ball.spd;
        console.log("currentSpd = " + currentSpd);
        return currentSpd;
    }

    function serve() {
        //ball already in motion
        if (ball.yv != 0) {
            return false;
        }
        //random angle, between 45 and 135 degrees
        let angle = Math.random() * Math.PI / 2 + Math.PI / 4;
        //applyBallSpeed(pupSticky ? relativeBounce(ball.spd) : angle);
        if (!pupSticky) {
            applyBallSpeed(angle);
            fxPaddle.play();
            return true;
        } else if (pupSticky) {
            relativeBounce(currentSpd);
            fxPaddle.play();
            return true;
        }
    }

    function setDimensions() {
        height = window.innerHeight; 
        width = window.innerWidth; 
        wall = WALL * (height < width ? height : width);
        canv.width = width;
        canv.height = height;
        ctx.textBaseLine = "middle";
        newGame();
    }

    function touchCancel(ev) {
        touchX = null;
        movePaddle(Direction.STOP);
    }

    function touchEnd(ev) {
        touchX = null;;
        movePaddle(Direction.STOP)
    }

    function touchMove(ev) {
        touchX = ev.touches[0].clientX;
    }

    function touchStart(ev) {
        if (serve()) {
            if (gameOver) {
                newGame();
                }
            return;
        }
        touchX = ev.touches[0].clientX;
    }

    function updatePaddle(delta) {
        //handle touch
        if (touchX != null) {
            if (touchX > paddle.x + wall) {
                movePaddle(Direction.RIGHT);
            } else if (touchX < paddle.x - wall) {
                movePaddle(Direction.LEFT);
            } else {
                movePaddle(Direction.STOP);
            }
        }

        //move paddle
        let lastPaddleX = paddle.x
        paddle.x += paddle.xv * delta;

        //stop paddle at walls
        if (paddle.x < wall + paddle.w * 0.5) {
            paddle.x = wall + paddle.w * 0.5;
        } else if (paddle.x > canv.width - wall - paddle.w * 0.5) {
            paddle.x = canv.width - wall - paddle.w * 0.5;
        }

        //move stationary ball with paddle
        if (ball.yv == 0) {
            ball.x += paddle.x - lastPaddleX;
        }

        //collect powerups
        for (let i = pups.length - 1; i >= 0; i--) {
            if (pups[i].x + pups[i].w * 0.5 > paddle.x - paddle.w * 0.5
                && pups[i].x - pups[i].w * 0.5 < paddle.x + paddle.w * 0.5
                && pups[i].y + pups[i].h * 0.5 > paddle.y - paddle.h * 0.5
                && pups[i].y - pups[i].h * 0.5 < paddle.y + paddle.h * 0.5
            ) {
                switch(pups[i].type) {
                    case PupType.EXTENSION:
                        //double width of paddle
                        if (pupExtension) {
                            score += PUP_BONUS;
                        } else {
                            pupExtension = true;
                            paddle.w *= 2
                        } break;
                    case PupType.LIFE:
                        //add a life (max 5)
                        if (lives >= 5) {
                            score += PUP_BONUS
                        } else {
                             lives++;
                        } break;
                    case PupType.STICKY:
                        //paddle "holds" ball for another serve
                        if (pupSticky) {
                                score += PUP_BONUS;
                            } else {
                                pupSticky = true;
                            } break;
                    case PupType.SUPER:
                        //double width of paddle
                        if (pupSuper) {
                            score += PUP_BONUS;
                        } else {
                            pupSuper = true;
                        } break;
                }
                pups.splice(i, 1);
                fxPowerUp.play();
            }
        }         
    }
    

    function updateBall(delta) {
        var intersectX, ballSpeed, influenceX;
        ball.x += ball.xv * delta;
        ball.y += ball.yv * delta;

        //bounce ball off walls
        if (ball.x < wall + ball.w * 0.5) {
            ball.x = wall + ball.w * 0.5;
            ball.xv = -ball.xv;
            fxWall.play();
        } else if (ball.x > canv.width - wall - ball.w * 0.5) {
            ball.x = canv.width - wall - ball.w * 0.5;
            ball.xv = -ball.xv; 
            fxWall.play();
        } else if (ball.y < wall + ball.h * 0.5) {
            ball.y = wall + ball.h * 0.5;
            ball.yv = -ball.yv;
            fxWall.play();
        }

        //bounce ball off paddle - SIMPLE BOUNCE
        //if (ball.y > paddle.y - paddle.h * 0.5 - ball.h * 0.5
        //    && ball.y < paddle.y + paddle.y + paddle.h * 0.5
        //    && ball.x > paddle.x - paddle.w * 0.5 - ball.w * 0.5
        //    && ball.x < paddle.x + paddle.w * 0.5 - ball.w * 0.5
        //    ) {
        //        ball.y = paddle.y - paddle.h * 0.5 - ball.h * 0.5;
        //        ball.yv = -ball.yv;
        //    }

        //bounce ball off paddle based on where ball hits paddle
        if (ball.y > paddle.y - paddle.h * 0.5 - ball.h * 0.5
            && ball.y < paddle.y + paddle.h * 0.5
            && ball.x > paddle.x - paddle.w * 0.5 - ball.w * 0.5
            && ball.x < paddle.x + paddle.w * 0.5 - ball.w * 0.5
            ) {
                ball.y = paddle.y - paddle.h * 0.5 - ball.h * 0.5;
                if (pupSticky) {
                    ball.xv = 0;
                    ball.yv = 0
                } else {
                relativeBounce(ballSpeed);
                }
            }
        

        //handle out of bounds
        if (ball.y > canv.height) {
            outOfBounds();
        }
    }

    function relativeBounce() {
        ballSpeed = currentSpd;
        intersectX = (ball.x - paddle.x) / paddle.w * 0.5;
        influenceX = 1;
        ball.xv = ballSpeed * intersectX * influenceX;
        ball.yv = Math.sqrt(ballSpeed * ballSpeed - ball.xv * ball.xv) *
        (ball.yv > 0 ? -1 : 1);
        fxPaddle.play();
    }

    function updateBricks(delta) {

        //check for ball collisions
        OUTER: for (let i = 0; i < bricks.length; i++) {
            for (let j = 0; j < BRICK_COLS; j++) {
                if (bricks[i][j] != null && bricks[i][j].intersect(ball)) {
                    updateScore(bricks[i][j].score);
                    ball.setSpd(bricks[i][j].spdMult);
                    fetchCurrentSpd();

                    //set ball to edge of brick (help with clipping at high speeds)
                    if (ball.yv < 0) { //upwards
                        ball.y = bricks[i][j].bot + ball.h * 0.5;
                    } else { //downwards
                        ball.y = bricks[i][j].top - ball.h * 0.5;    
                    }

                    //create powerup
                    if (Math.random() <= PUP_CHANCE) {
                        let px = bricks[i][j].left + bricks[i][j].w / 2;
                        let py = bricks[i][j].top + bricks[i][j].h / 2;
                        let pSize = bricks[i][j].w / 2;
                        let pKeys = Object.keys(PupType);
                        let pKey = pKeys[Math.floor(Math.random() * pKeys.length)];
                        pups.push(new PowerUp(px, py, pSize, PupType[pKey]));
                    }


                    //bounce ball if not super ball and destroy brick
                    if (!pupSuper) {
                    ball.yv = -ball.yv
                    }
                    bricks[i][j] = null;
                    numBricks--;
                    fxBrick.play();
                    break OUTER;
                }
            }
        }

        //next level
        if (numBricks == 0) {
            if (level < MAX_LEVEL) {
                level++;
                newLevel();
            } else {
                gameOver = true;
                win = true;
                newBall();
            }
        }
    }

    function updatePups(delta) {
        for (let i = pups.length - 1; i >= 0; i--) {
            pups[i].y += pups[i].yv * delta;

            //delete off-screen powerups
            if (pups[i].y - pups[i].h * 0.5 > height) {
                pups.splice(i, 1);
            }
        }
    }

    function updateScore(brickScore) {
        score += brickScore;

        //check for high score
        if (score > scoreHigh) {
            scoreHigh = score;
            localStorage.setItem(KEY_SCORE, scoreHigh);
        }
    }

    function Paddle() {
        this.w = PADDLE_W * width;
        this.h = wall * PADDLE_SIZE;
        this.x = canv.width / 2;
        this.y = canv.height - wall * 3.5 + this.h / 2;
        this.xv = 0;
        this.spd = PADDLE_SPD * width;
    }

    function Ball() {
        this.w = wall;
        this.h = wall;
        this.x = paddle.x;
        this.y = paddle.y - paddle.h / 2 - this.h / 2;
        this.xv = 0;
        this.yv = 0;
        this.spd = BALL_SPD * height;

        this.setSpd = function(spdMult) {
            this.spd = Math.max(this.spd, BALL_SPD * height * spdMult);
            console.log("spd=" + this.spd);
        }
    }

    function Brick(left, top, w, h, color, score, spdMult) {
        this.w = w;
        this.h = h;
        this.bot = top + h;
        this.left = left;
        this.right = left + w;
        this.top = top;
        this.color = color;
        this.score = score;
        this.spdMult = spdMult;


        this.intersect = function(ball) {
            let bBot = ball.y + ball.h * 0.5
            let bLeft = ball.x - ball.w * 0.5
            let bRight = ball.x + ball.w * 0.5
            let bTop = ball.y - ball.h * 0.5
            return this.left < bRight
                && bLeft < this.right
                && this.bot > bTop
                && bBot > this.top;
        }
    }

    function PowerUp(x, y, size, type) {
        this.w = size;
        this.h = size;
        this.x = x;
        this.y = y;
        this.type = type;
        this.yv = PUP_SPD * height;
    }
</script>
    
</body>
</html>
